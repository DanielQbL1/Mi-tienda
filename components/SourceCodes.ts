
// Este archivo contiene el código fuente de los componentes para la función de descarga
// Se usa para generar el ZIP sin necesidad de hacer fetch al servidor

export const SOURCE_FILES: Record<string, string> = {
  'supabase_setup.sql': `-- EJECUTAR EN SUPABASE SQL EDITOR --

-- 1. Tabla de Datos de la Tienda (Configuración, Productos, Pedidos)
DROP TABLE IF EXISTS store_data;
CREATE TABLE store_data (
  id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  products jsonb,
  categories jsonb,
  settings jsonb,
  zones jsonb,
  banners jsonb,
  coupons jsonb,
  orders jsonb,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);
ALTER TABLE store_data ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public Access Store" ON store_data FOR ALL USING (true) WITH CHECK (true);
INSERT INTO store_data (id) VALUES (1);

-- 2. Tabla de Usuarios (Clientes)
-- Nota: En producción idealmente usarías Supabase Auth (GoTrue), 
-- pero esto mantiene la lógica simple de tu app actual.
CREATE TABLE IF NOT EXISTS app_users (
  id text PRIMARY KEY,
  email text UNIQUE,
  password text, -- En producción, esto debe ser hasheado
  name text,
  role text DEFAULT 'user',
  avatar text,
  phone text,
  address text,
  settings jsonb,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);
ALTER TABLE app_users ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public Access Users" ON app_users FOR ALL USING (true) WITH CHECK (true);
`,

  'supabaseStore.ts': `import { createClient } from '@supabase/supabase-js';
import { DEFAULT_SETTINGS } from './constants';

const cleanUrl = (url: string | undefined) => {
  if (!url) return "";
  let cleaned = url.trim();
  if (cleaned.endsWith('/')) { cleaned = cleaned.slice(0, -1); }
  return cleaned;
};

const supabaseUrl = cleanUrl(DEFAULT_SETTINGS.supabaseUrl);
const supabaseKey = DEFAULT_SETTINGS.supabaseKey?.trim() || '';

export const supabase = (supabaseUrl && supabaseKey) 
  ? createClient(supabaseUrl, supabaseKey, { auth: { persistSession: true, autoRefreshToken: true }, db: { schema: 'public' } }) 
  : null;

export async function loadStoreFromSupabase() {
  if (!supabase) return null;
  try {
    const { data, error } = await supabase.from('store_data').select('*').eq('id', 1).single();
    if (error) { console.warn(\`Supabase load error: \${error.code}\`); return null; }
    return data;
  } catch (e) { console.error('Unexpected error loading from Supabase:', e); return null; }
}`,

  'components/StoreContext.tsx': `import React, { createContext, useContext, useState, useEffect, useCallback, ReactNode } from 'react';
import { Product, CartItem, User, StoreSettings, DeliveryZone, Order, Banner, Coupon } from '../types';
import { INITIAL_PRODUCTS, INITIAL_CATEGORIES, DEFAULT_SETTINGS, INITIAL_ZONES, INITIAL_BANNERS, INITIAL_COUPONS } from '../constants';
import { loadStoreFromSupabase, supabase as defaultSupabase } from '../supabaseStore';
import { createClient } from '@supabase/supabase-js';

const safeSetItem = (key: string, value: string) => { try { localStorage.setItem(key, value); } catch (e) {} };
const getInitialState = <T,>(key: string, fallback: T): T => { try { const saved = localStorage.getItem(\`shoespots_\${key}\`); return saved ? JSON.parse(saved) : fallback; } catch { return fallback; } };

interface StoreContextType {
  products: Product[]; categories: any[]; settings: StoreSettings; deliveryZones: DeliveryZone[]; orders: Order[]; banners: Banner[]; coupons: Coupon[]; cart: CartItem[]; favorites: number[]; user: User | null; isLoading: boolean; toastMessage: string | null;
  setProducts: (p: Product[]) => void; setCategories: (c: any[]) => void; setSettings: (s: StoreSettings) => void; setDeliveryZones: (z: DeliveryZone[]) => void; setBanners: (b: Banner[]) => void; setCoupons: (c: Coupon[]) => void; setOrders: (o: Order[]) => void;
  addToCart: (product: Product, size: string) => void; removeFromCart: (id: number, size: string) => void; updateCartQuantity: (id: number, size: string, delta: number) => void; clearCart: () => void; toggleFavorite: (id: number) => void; 
  loginUser: (email: string, pass: string) => Promise<boolean>; registerUser: (name: string, email: string, pass: string) => Promise<boolean>; logout: () => void; updateUser: (user: User) => Promise<void>; showToast: (msg: string) => void;
}

const StoreContext = createContext<StoreContextType | undefined>(undefined);

export const StoreProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [products, setProductsState] = useState<Product[]>(() => getInitialState('products', INITIAL_PRODUCTS));
  const [categories, setCategoriesState] = useState<any[]>(() => getInitialState('categories', INITIAL_CATEGORIES));
  const [settings, setSettingsState] = useState<StoreSettings>(() => getInitialState('settings', DEFAULT_SETTINGS));
  const [deliveryZones, setDeliveryZonesState] = useState<DeliveryZone[]>(() => getInitialState('zones', INITIAL_ZONES));
  const [orders, setOrdersState] = useState<Order[]>(() => getInitialState('orders', []));
  const [banners, setBannersState] = useState<Banner[]>(() => getInitialState('banners', INITIAL_BANNERS));
  const [coupons, setCouponsState] = useState<Coupon[]>(() => getInitialState('coupons', INITIAL_COUPONS));
  const [cart, setCart] = useState<CartItem[]>(() => getInitialState('cart', []));
  const [favorites, setFavorites] = useState<number[]>(() => getInitialState('favs', []));
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [toastMessage, setToastMessage] = useState<string | null>(null);

  // Helper to get active supabase client (default or custom from settings)
  const getClient = () => {
      let client = defaultSupabase;
      const cleanDefaultUrl = (DEFAULT_SETTINGS.supabaseUrl || "").replace(/\/$/, "");
      const cleanCurrentUrl = (settings.supabaseUrl || "").replace(/\/$/, "");
      if (cleanCurrentUrl && settings.supabaseKey && (cleanCurrentUrl !== cleanDefaultUrl || settings.supabaseKey !== DEFAULT_SETTINGS.supabaseKey)) { client = createClient(cleanCurrentUrl, settings.supabaseKey); }
      return client;
  };

  useEffect(() => safeSetItem('shoespots_cart', JSON.stringify(cart)), [cart]);
  useEffect(() => safeSetItem('shoespots_favs', JSON.stringify(favorites)), [favorites]);
  
  useEffect(() => {
    let mounted = true;
    async function syncData() {
      try {
        setIsLoading(true);
        const data = await loadStoreFromSupabase();
        if (mounted && data) {
            setProductsState(data.products || []); setCategoriesState(data.categories || []); setSettingsState(data.settings || DEFAULT_SETTINGS); setDeliveryZonesState(data.zones || []); setBannersState(data.banners || []); setCouponsState(data.coupons || []); setOrdersState(data.orders || []);
            // Persist local cache
            safeSetItem('shoespots_products', JSON.stringify(data.products)); safeSetItem('shoespots_categories', JSON.stringify(data.categories)); safeSetItem('shoespots_settings', JSON.stringify(data.settings)); safeSetItem('shoespots_zones', JSON.stringify(data.zones)); safeSetItem('shoespots_banners', JSON.stringify(data.banners)); safeSetItem('shoespots_coupons', JSON.stringify(data.coupons)); safeSetItem('shoespots_orders', JSON.stringify(data.orders));
        }
      } catch (err) {} finally { if (mounted) setIsLoading(false); }
    }
    syncData();
    return () => { mounted = false; };
  }, []);

  const showToast = useCallback((msg: string) => { setToastMessage(msg); setTimeout(() => setToastMessage(null), 3000); }, []);
  
  const saveGlobalState = async (field: string, data: any) => {
      safeSetItem(\`shoespots_\${field}\`, JSON.stringify(data));
      const client = getClient();
      if (client) { try { const updateObj: any = { id: 1 }; const dbField = field === 'deliveryZones' ? 'zones' : field; updateObj[dbField] = data; updateObj.updated_at = new Date().toISOString(); await client.from('store_data').upsert(updateObj); } catch (e) { console.error("Cloud Save Error:", e); } }
  };

  const setProducts = useCallback((val: Product[]) => { setProductsState(val); saveGlobalState('products', val); }, [settings]);
  const setCategories = useCallback((val: any[]) => { setCategoriesState(val); saveGlobalState('categories', val); }, [settings]);
  const setSettings = useCallback((val: StoreSettings) => { setSettingsState(val); saveGlobalState('settings', val); }, [settings]);
  const setDeliveryZones = useCallback((val: DeliveryZone[]) => { setDeliveryZonesState(val); saveGlobalState('zones', val); }, [settings]);
  const setBanners = useCallback((val: Banner[]) => { setBannersState(val); saveGlobalState('banners', val); }, [settings]);
  const setCoupons = useCallback((val: Coupon[]) => { setCouponsState(val); saveGlobalState('coupons', val); }, [settings]);
  const setOrders = useCallback((val: Order[]) => { setOrdersState(val); saveGlobalState('orders', val); }, [settings]);

  const addToCart = useCallback((product: Product, size: string) => { setCart(prev => { const existing = prev.find(item => item.id === product.id && item.selectedSize === size); if (existing) { return prev.map(item => item.id === product.id && item.selectedSize === size ? { ...item, quantity: item.quantity + 1 } : item); } return [...prev, { ...product, selectedSize: size, quantity: 1 }]; }); showToast('Añadido a la bolsa'); }, [showToast]);
  const removeFromCart = useCallback((id: number, size: string) => { setCart(prev => prev.filter(item => !(item.id === id && item.selectedSize === size))); }, []);
  const updateCartQuantity = useCallback((id: number, size: string, delta: number) => { setCart(prev => prev.map(item => (item.id === id && item.selectedSize === size) ? { ...item, quantity: Math.max(1, item.quantity + delta) } : item)); }, []);
  const clearCart = useCallback(() => setCart([]), []);
  const toggleFavorite = useCallback((id: number) => { setFavorites(prev => prev.includes(id) ? prev.filter(f => f !== id) : [...prev, id]); }, []);

  // --- AUTH METHODS (Supabase Connected) ---
  const loginUser = useCallback(async (email: string, pass: string) => {
      // 1. Admin Hardcoded
      if (email === 'admin' && pass === 'admin') {
          setUser({ id: 'admin', name: 'Administrador', email: 'admin@shoespot.com', role: 'admin', avatar: 'https://cdn-icons-png.flaticon.com/512/2942/2942813.png', settings: { location: 'Admin HQ' } });
          showToast('Bienvenido Admin');
          return true;
      }
      // 2. Try Supabase
      const client = getClient();
      if(client) {
          try {
              const { data, error } = await client.from('app_users').select('*').eq('email', email).eq('password', pass).single();
              if(data && !error) {
                  setUser(data);
                  showToast(\`Bienvenido \${data.name}\`);
                  return true;
              }
          } catch(e) {}
      }
      // 3. Fallback Local Storage
      const usersDbStr = localStorage.getItem('shoespots_users_db');
      if (usersDbStr) {
          const users = JSON.parse(usersDbStr);
          const localUser = users.find((u: User) => u.email === email && u.password === pass);
          if (localUser) { setUser(localUser); showToast(\`Bienvenido \${localUser.name}\`); return true; }
      }
      return false;
  }, [settings, showToast]);

  const registerUser = useCallback(async (name: string, email: string, pass: string) => {
      const newUser: User = { id: Date.now().toString(), name, email, password: pass, role: 'user', avatar: 'https://cdn-icons-png.flaticon.com/512/149/149071.png', settings: { location: 'La Habana' } };
      const client = getClient();
      let savedCloud = false;
      if(client) {
          try {
              // Check existing
              const { data: exist } = await client.from('app_users').select('id').eq('email', email).single();
              if(exist) return false; // Email taken
              const { error } = await client.from('app_users').insert(newUser);
              if(!error) savedCloud = true;
          } catch(e) {}
      }
      // Save local always as backup
      const usersDbStr = localStorage.getItem('shoespots_users_db');
      const users = usersDbStr ? JSON.parse(usersDbStr) : [];
      if(!savedCloud && users.some((u: User) => u.email === email)) return false;
      
      users.push(newUser);
      localStorage.setItem('shoespots_users_db', JSON.stringify(users));
      setUser(newUser);
      showToast('Cuenta creada con éxito');
      return true;
  }, [settings, showToast]);

  const updateUser = useCallback(async (updatedUser: User) => {
      setUser(updatedUser);
      const client = getClient();
      if(client && updatedUser.role !== 'admin') {
          try { await client.from('app_users').update(updatedUser).eq('id', updatedUser.id); } catch(e) {}
      }
      // Local Sync
      const usersDbStr = localStorage.getItem('shoespots_users_db');
      if(usersDbStr) {
          const users = JSON.parse(usersDbStr);
          const newUsers = users.map((u: User) => u.email === updatedUser.email ? updatedUser : u);
          localStorage.setItem('shoespots_users_db', JSON.stringify(newUsers));
      }
      showToast('Perfil actualizado');
  }, [settings, showToast]);

  const logout = useCallback(() => { setUser(null); showToast('Sesión cerrada'); }, [showToast]);

  return (
    <StoreContext.Provider value={{ products, categories, settings, deliveryZones, orders, banners, coupons, cart, favorites, user, isLoading, toastMessage, setProducts, setCategories, setSettings, setDeliveryZones, setBanners, setCoupons, setOrders, addToCart, removeFromCart, updateCartQuantity, clearCart, toggleFavorite, loginUser, registerUser, logout, updateUser, showToast }}>
      {children}
    </StoreContext.Provider>
  );
};
export const useStore = () => { const context = useContext(StoreContext); if (context === undefined) throw new Error('useStore must be used within a StoreProvider'); return context; };`,

  'App.tsx': `// ... (Rest of App.tsx content remains similar, will be updated via other file blocks if needed) ...`
};
